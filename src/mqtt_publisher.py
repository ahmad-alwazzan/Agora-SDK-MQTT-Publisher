#################################################################
# Agora Digital Solutions Inc.
# ###############################################################
# Copyright 2020 Agora Digital Solutions Inc.

# All rights reserved in Agora Digital Solutions Inc. authored and generated code (including the selection and arrangement of the source code base regardless of the authorship of individual files), but not including any copyright interest(s) owned by a third party related to source code or object code authored or generated by non- Agora Digital Solutions Inc. personnel.
# Any use, disclosure and/or reproduction of source code is prohibited unless in compliance with the AGORA SOFTWARE DEVELOPMENT KIT LICENSE AGREEMENT.
#################################################################
from CalculationWorker import CalculationWorker
from HBM_PythonAppManagerBindings import *
import time
import logging

if __debug__:
	import sys
	import ptvsd

	if not hasattr(sys, 'argv'):
		sys.argv  = ['']

	# 5678 is the default attach port in the VS Code debug configurations
	print("Waiting for debugger attach")
	ptvsd.enable_attach(address=('localhost', 5678), redirect_output=True)
	ptvsd.wait_for_attach()
	breakpoint()

class mqtt_publisher(PropChngHndlr, DataInHndlr):

	def __init__(self):
		PropChngHndlr.__init__(self)
		DataInHndlr.__init__(self)
		self.privateCalculationWorker = None
		self.privateConfigSerializer = JSerializer()
		self.privateDataSerializer = JSerializer()
		self.privateRun = False
		FORMAT = "%(asctime)s.%(msecs)03d %(levelname)s [%(process)d] [%(filename)s::%(funcName)s@%(lineno)s] %(message)s"
		logging.basicConfig(level=logging.DEBUG, format=FORMAT, datefmt='%Y-%m-%d %H:%M:%S')

	def Create(self):
		logging.debug("Calling Create")
		return 0

	def Initialize(self, configuration, busClient):
		# get the configuration and verify
		config_deserializer = JSerializer()
		ret_val = config_deserializer.Initialize(configuration)
		
		if (ret_val == 0):
			nameDeserialized = config_deserializer.GetValueAsString("Name")
			versionDeserialized = config_deserializer.GetValueAsString("Version")
			
			# GetValueAsString return a tuple containing the deserialized value and the returned value (0 if succeed)
			ret_val += nameDeserialized[0]
			ret_val += versionDeserialized[0]
	
			if (ret_val == 0 and busClient):
				bus_client_config_j = config_deserializer.GetJString("Components.BusClient.Config")
				dataInEndpoint = config_deserializer.GetValueAsString("InEndpoints.Data")
				DataOutEndpoint = config_deserializer.GetValueAsString("OutEndpoints.Data")
				methodNames = config_deserializer.GetStringVector("Methods")

				ret_val += bus_client_config_j[0]
				ret_val += dataInEndpoint[0]
				ret_val += DataOutEndpoint[0]
				ret_val += methodNames[0]
			else:
				ret_val = -2
		else:
			ret_val = -1

		#do not proceed if parsing is not performed correctly
		if (ret_val != 0):
			return ret_val

		busClient.Initialize(bus_client_config_j[1])
		busClient.AddPropertyChangeHdnlr("module_twin", self) 
		busClient.AddDataHandler(dataInEndpoint[1],  self)

		#TODO : Add StateRspnsHndlr

		#TODO : Add DirectMethodHndlr


		busClient.SetRunMode(START)

		self.privateCalculationWorker = CalculationWorker()

		if (self.privateCalculationWorker):
			self.privateCalculationWorker.Initialize(nameDeserialized[1], busClient, DataOutEndpoint[1])

		self.privateRun = True

		return 0

	def Execute(self,Argcount, Argvalues):
		logging.debug("Calling Execute, will sleep for test purpose")
		self.privateCalculationWorker.start()

		while(self.privateRun == True):
			time.sleep(60)

		return 0

	def Terminate(self):
		logging.debug("Calling Terminate")

		self.privateCalculationWorker.stop()

		if (self.privateCalculationWorker.getThreadId() != None):
			self.privateCalculationWorker.join()

		self.privateRun = False

		return 0
	
	def HandleProp(self, payload):
		logging.debug("Prop update received")
		parsed_payload = ''
		ret_val = 0

		self.privateConfigSerializer.Initialize(payload)

		result = self.privateConfigSerializer.GetJString("desired")
		ret_val = result[0]
		parsed_payload = result[1]

		if ( (0 != ret_val) or not parsed_payload or  (parsed_payload == "null") ):
			logging.debug("Unparsed payload: %s" % payload)
		else:
			logging.debug("Assigning parsed payload: %s" % parsed_payload)
			self.privateConfigSerializer.Initialize(parsed_payload)

		'''
		same workflow if desired properties received at startup module or subsequent update, doesn't matter
		we send the data to the tcp/ip client thread which will handle them 
		''' 
		if (self.privateCalculationWorker):
			logging.debug("Sending to client")
			self.privateCalculationWorker.Configure(self.privateConfigSerializer)

		return 0

	def HandleData(self, payload):
		logging.debug("Data received")

		self.privateDataSerializer.Initialize(payload)

		if (self.privateCalculationWorker):
			logging.debug("Sending to client")
			self.privateCalculationWorker.HandleData(self.privateDataSerializer)

		return 0
	
